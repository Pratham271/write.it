import { Context } from "hono";
import {load} from "cheerio"
import { RecursiveCharacterTextSplitter } from "langchain/text_splitter";
import { MemoryVectorStore } from "langchain/vectorstores/memory";
import { CohereEmbeddings } from "@langchain/cohere";
import { ChatPromptTemplate } from "@langchain/core/prompts";
import { ChatGroq } from "@langchain/groq";
import axios from 'axios';
const links = [
    "https://medium.com",
    "https://notion.com/",
    "https://hashnode.com/explore/blog/s",
    "https://www.linkedin.com/blog/",
    "https://www.quora.com/",
    "https://dev.to/",
    "https://discover.hubpages.com/",
    "https://vocal.media/",
    "https://substack.com/browse",
    "https://wordpress.com/blog/",
    "https://ghost.org/explore/",
    "https://vercel.com/docs",
    "https://react.dev/blog",
]



interface ContentResult {
    link: string
    html: string;
}
export async function fetchLinks(c:Context,userInput:string){
    const embeddings = new CohereEmbeddings({
        apiKey: c.env.COHERE_API_KEY,
    });
    const linksInfo = await get10BlueLinksContent(links)
    const vector = await processAndVectorizeContent(linksInfo,userInput,embeddings)
    return vector
}

async function fetchWithTimeout(url:string, options: RequestInit={}): Promise<Response>{
    try {
        const controller = new AbortController()
        const timeoutId = setTimeout(()=> controller.abort(), 800);
        const response = await fetch(url, {...options,signal:controller.signal});
        clearTimeout(timeoutId);
        return response;
    } catch (error) {
        if(error){
            console.log(`Skipping ${url}`)
        }
        throw error;
    }
}

// extract the main content of the link
function extractMainContent(html:string):string{
    try {
        const page = load(html)
        page("script, style, head, nav, footer, iframe, img").remove()
        return page("body").text().replace(/\s+/g, " ").trim()
    } catch (error) {
        console.log('Error in extracting the main content: ',error)
        throw error;
    }
}

// get the contents of the links generated by the brave search api
async function get10BlueLinksContent(sources: string[]): Promise<ContentResult[]>{
    const promises = sources.map(async (source): Promise<ContentResult | null> => {
        try {
            const response = await fetchWithTimeout(source,{})
            if(!response.ok){
                throw new Error(`Failed to fetch ${source}, Status: ${response.status}`)
            }
            const html = await response.text()
            const mainContent = extractMainContent(html)
            return {link:source, html:mainContent}
        } catch (error) {
            return null
        }
    });
    try {
        const results = await Promise.all(promises) 
        return results.filter((source): source is ContentResult=> source!==null);
    } catch (error) {
        console.log(`Error fetching links content: ${error}`)
        throw error
    }
}

async function processAndVectorizeContent(contents: ContentResult[], query: string,embeddings:any){
    try {
        // taking in each content or link result and splitting it to convert it into more mangeable chunks
        for(let i=0; i<contents.length; i++){
            const content = contents[i]
            if(content.html.length>0){
                try {
                    // chunk size controls the max size(in terms of number of characters) of the final documents
                    // chunkOverlap specifies how much overlap there should be between chunks
                    const splitText = await new RecursiveCharacterTextSplitter({chunkSize:1000, chunkOverlap: 400}).splitText(content.html)
                    // to convert the text into a vector store which is done using the text embeddings model
                    const vectorStores = await MemoryVectorStore.fromTexts(splitText, { link:content.link }, embeddings)
                    // to return 4 similarity results
                    return vectorStores
                } catch (error) {
                    console.error(`Error processing content for ${content.link}:`,error)
                }
            }
        }
        return []
    } catch (error) {
        console.error('Error processing and vectorising content: ',error)
        throw error
    }
}

export async function titleGenerator(c:Context,userInput:string){
    const model = new ChatGroq({
        apiKey: c.env.GROQ_API_KEY,
      });
    
    const prompt = ChatPromptTemplate.fromMessages([
        ["system", "You are a world class blog title generator and you only generate title based on the input provided by the user"],
        ["user", "{input}"],
    ]);

    const chain = prompt.pipe(model);
    const title = await chain.invoke({
        input: `Generate 10 title for the blog ${userInput}`,
      });
    // console.log(title.content)
    const finalTitle = retrieveTitles(title.content as string)

    return finalTitle;
}

function retrieveTitles(input:string) {
    const regex = /(?<=^\d+\.\s|\*|\").([^\n]*)/gm;
    const titles:string[] = [];
    let match;
    while ((match = regex.exec(input)) !== null) {
      titles.push(match[0]);
    }
    return titles[0];
}

export async function ImageLink(c:Context,userInput:string){
    const words = userInput.split(" ")
    const input  = words[words.length-1]
    const response = await fetch(`https://api.search.brave.com/res/v1/images/search?q=${encodeURIComponent(input)}&spellcheck=1`, {
        method: "GET",
        headers: {
            "Accept": "application/json",
            "Accept-Encoding": "gzip",
            "X-Subscription-Token": c.env.BRAVE_API_KEY as string
        }
    });
    if(!response.ok){
        console.log(`Error fetching the images. Status: ${response.status}`)
        return [{title:'',link:''}];
        // throw new Error(`Error fetching the images. Status: ${response.status}`)
    }

    const data:any = await response.json()
        // there were some instances where the links were broken and not a good experience for the user 
        // optional step can totally skip it 
        // console.log(data)
        const validLinks = await Promise.all(
            data.results.map(async (result: any)=> {
                const link = result.properties.url;
                if(typeof link === 'string'){
                    try {
                        const imageResponse = await fetch(link, {method: 'HEAD'});
                        if(imageResponse.ok){
                            const contentType = imageResponse.headers.get('content-type');
                            if(contentType && contentType.startsWith('image/')){
                                return {
                                    title: result.properties.title,
                                    link: link
                                }
                            }
                        }
                    } catch (error) {
                        console.error(`Error fetching the image link ${link}:`, error)
                    }
                }
                return null
            })
        );
        // to filter out the links that are null and do not assert to the type specified just a guard function to make sure everything is fine
        const filteredLinks = validLinks.filter((link): link is {title: string, link: string} => link!==null)
        const rand = Number(Math.random().toFixed(1))*10;

        // returning 10 images as we are fetching 10 pages just to be similar can increase and decrease according to your choice 
        return filteredLinks[rand]
}